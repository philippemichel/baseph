---
title: "Vignette baseph"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Put the title of your vignette here}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE, warning = FALSE, message = FALSE, 
  out.width = '80%',
  fig.align = 'center'
)
```

 Ce package a pour but d'aider à réaliser la partie statistique d'une étude clinique simple, typiquement une thèse ou un mémoire de DES.
 
 Les données proposées sont fictives. 

# Installation

```{r insta, eval = FALSE}
devtools::install_github("https://github.com/philippemichel/baseph")
```

Tout simplement. Il vous faut juste le package `devtools`.


```{r setup, echo = FALSE}
library(labelled)
library(tidyverse)
library(baseph)
library(binom)
library(colorspace)
library(WriteXLS)
library(kableExtra)
```

 
 
# Les données

Pour tous les exemples suivant on utilise deux fichiers (dans le dossier `data`: 

- **patient.csv** qui contient des données fictives sur des patients.
- **noms.sv** qui contient une colonne `code` avec les noms des variables (ex : *igs2*) & une colonne `nom` qui contient les vrais noms de la variable pour un affichage clair dans les tableaux, graphiques etc. (ex : *IGS 2*). Un exmeple d'utilisation pourrait être :

```{r import}
# Création du vecteur de noms
nn <- read_csv("/home/philm/pratique/baseph/data/noms.csv")
bnom <- nn$nom
# Import de la base de données & incorporation des labels.
pat <- debutph("/home/philm/pratique/baseph/data/patients.csv", bnom)
```

# Avant l'analyse des données

## Calcul du nombre de cas

Quelques calculs du nombre de cas nécessaires pour des circonstances particulières.


### Non infériorité & équivalence. 

calcul du nombre de cas pour des études d'équivalence ou de non infériorité quand le test principal repose sur une variable binaire.

```{r noninf, }
nb.noninf.ph(po = 0.5,# proportion sur le groupe contrôle
             dl = 0.1, # 	déviation jugée comme acceptable
             zalpha = 0.05, # risque alpha
             zbeta = 0.2) # risque beta
```

```{r equi}
nb.equi.ph(po=0.5, dl = 0.1, zalpha = 0.05, zbeta = 0.2)
```

### Étude observationelle simple

Cette méthode permet d'avoir une estimation du nombre de cas nécessaire dans une étude purement observationnelle, sans test donc pas de calcul précis possible. Il faut néanmoins définir la marge d'erreur admissible sur les résultats.

```{r obs}
nb.obs.ph(px = 0.5, ex = 0.1, np = 1e5)
```


## Randomisation


Cette fonction, basée sur la fonction `blockrand` du package homonyme permet de créer les tables de randomisation (aléatoire) pour une étude sur plusieurs centres & pour deux classes (traitement 1 vs traitement B par ex.) ou plus. 

```{r rand, eval = FALSE} 
listrandph(nbcent = 1, # nombre de centres
          nbtrait = 2, #Nombre de modalités
          nbcas = 100 # nb de cas total voulu
           )
```
La sortie consiste en un fichier global & un par centre (csv).


# Tableau 1

Le premier tableau d'une étude est toujours un tableau simple, sans test (enfin presque toujours). Pour les valeurs numériques on peut choisir l’affichage de la moyenne ± écart-type (test = "moy") ou de la médiane (quartiles) (test = "med").

```{r tab1}
tab1ph(dfx = pat, test = "med",  note = "Tableau 1")
```


# Tableaux comparatifs. 

## Analyse univariée

Ce tableau sert à présenter les résultats de tests variable par variable.  On peut en particulier définir si on considère que les données numériques ont une distribution normale (présentation des résultats en moyenne ± écart-type, test de Student) ou non (présentation en médiane (quartiles), test de Wilcoxon).

```{r tabc}
tabcph(dfx = patients, tri = escarre, test = "moy", tit = "Escarre", note = "Facteurs de risque d'escarre")
```


## Analyse multivariée

On peut compléter l'analyse par une étude en multivariée par régression logistique.
La fonction `tabregph` prend comme principal argument le résultat d'un régression (grand nombre de modèles possibles, voir <https://www.danieldsjoberg.com/gtsummary/articles/tbl_regression.html#supported-models>).


```{r treg}
ll <- glm(escarre~ age + admission + igs2, data = pat, family = "binomial")
# tabregph(reg = ll, titre = "Facteurs de risque d'escarre" )
```

## Graphiques

## Une variable factorielle

Un graphique en barre simple pour afficher une donnée factorielle en % de chaque niveau.

```{r gsimple}
barsimpleph(
  dfx = pat,
  varx = admission,
  titre = "Mode d'admission",
  stitre = "ICU",
  capt = "Admission",
  lab = "graph1",
  angle = 30
)
```

### Graphique en barre décroissant

Le même , les items classés en % décroissant.
 
```{r gdec}
bardecph(patients, admission, titre = "Mode d'admission",
         stitre = "%"
         , capt = "Mode d'admission", lab ="ma", angle = 30)
```

## Deux variables factorielles

Une variable (y) représenté en % de  ses niveaux, découpé selon une seconde variable (x).

```{r gdeux}
bardeuxph(
  dfx =  patients,
  varp =  escarre,
  vart = admission ,
  titre = "Escarre & mode d'admission",
  stitre = "%",
  ltitre = "Escarre",
  capt = "Escarre",
  lab = "aa",
  angle = 20
)
```

## Une variable factorielle, une variable numérique

### Graphique en barre

Représentation de la moyenne avec son intervalle de confiance à 95 %  d'une variable numérique (y) selon les valeurs d'une variable factorielle (x).

```{r gcbonf}
barconfph(dfx = pat, varnum = igs2, vartri = admission, titre = "IGS II selon la provenance du patient", stitre = "en ICU", tx = "Mode d'admission", ty = "IGS II", angle = 0)
```

### Violons & boxplot

Représentation  d'une variable numérique (y) en violons (complété d'un boxplot) selon les valeurs d'une variable factorielle (x).

```{r gviol}
vioboxph(pat, admission, age, titre =" grands",stit = "et grandes", titx = "Mode d'admission")
```

# Utilitaires

## BMI ou IMC

À partir d'un vecteur contenant les valeurs numériques de l'IMC , discrétise selon les limites usuelles. À savoir ces limites sont différentes en France & chez les anglo-saxons d'où l’importance de choisir la langue.

```{r imc}
imc <- c(18,25,40,32)
bmiph(imc, "fr")
```

